use std::borrow::{Borrow, BorrowMut};
use std::collections::HashMap;
use std::fmt::{self, Debug};
use std::rc::Rc;

use bn_expression::basic::BasicOp;
use bn_expression::parse::{match_name_basic, ExpressionParser, IExpressionParser};
use bn_expression::{AValue, EvalContext, EvalError, Expression, FunctionType, ParseError};
use kstring::KString;
use reffers::rc::{Ref, RefMut, Strong};
use reffers::ARef;

use super::{
    consts::*,
    error::{CompileError, PassError, TResult},
    instruction::{InstValue, Instruction, InstructionJump, ResolveValues},
    macros::{MacroHandler, MacroWrap},
};
use crate::{
    builtin_macros::{self, UserMacro},
    common::string_cache::StringCache,
    parser::{
        parse_instruction_arg_string, Directive, DirectiveIf, DirectiveOption, Label, Source,
        Statement, StatementData, TokenParser,
    },
};

/// The mode with which to set or define a macro, constant, option, etc
///
/// In `CompilerEnv` this is used to control the scope in which values are manipulated.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum EnvMode {
    /// Use the default mode of this `CompilerEnv`
    Pass,
    /// Only get/set a value locally to this compiler
    Local,
    /// Get/set a value globally, ignoring default `CompilerEnv` settings
    Global,
}
impl EnvMode {
    pub fn with_default(self, other: Self) -> Self {
        match self {
            Self::Pass => other,
            _ => self,
        }
    }

    /// Returns the first mode from `modes` that doesn't equal `Pass`,
    /// or returns `Pass` if empty or all are `Pass`.
    pub fn take_first(modes: &[Self]) -> Self {
        for m in modes {
            if m != &Self::Pass {
                return *m;
            }
        }
        Self::Pass
    }

    /// Tries to convert a string into an `EnvMode`
    pub fn from_str_ignore_case(value: &str) -> Option<Self> {
        if value.eq_ignore_ascii_case("pass") {
            Some(Self::Pass)
        } else if value.eq_ignore_ascii_case("local") {
            Some(Self::Local)
        } else if value.eq_ignore_ascii_case("global") {
            Some(Self::Global)
        } else {
            None
        }
    }
}
impl Default for EnvMode {
    fn default() -> Self {
        Self::Pass
    }
}

/// API for the compiler to access certain system features
pub trait SystemApi: Debug {
    /// Resolve a path relative to `base` into an absolute path
    fn resolve_path(&self, base: &str, relative: &str) -> Result<String, std::io::Error>;
    /// Returns the contents of the file at `path` as a String
    fn fs_read_to_string(&mut self, path: &str) -> Result<String, std::io::Error>;
}

/// A simple implementation of `SystemApi` suitable for use with an OS.
#[cfg(any(target_family = "windows", target_family = "unix"))]
mod os_api {
    use std::io;
    use std::path::PathBuf;

    use super::SystemApi;

    #[derive(Debug, Default)]
    pub struct OsSystemApi {}

    impl OsSystemApi {
        pub fn new() -> Self {
            Self {}
        }
    }
    impl SystemApi for OsSystemApi {
        fn resolve_path(&self, base: &str, relative: &str) -> Result<String, io::Error> {
            let rel_path = PathBuf::from(relative);
            if rel_path.is_absolute() {
                Ok(relative.into())
            } else {
                let mut new_path = PathBuf::from(base);
                if new_path.is_file() {
                    new_path.pop();
                }
                new_path.push(relative);
                let new_path = new_path
                    .canonicalize()?
                    .into_os_string()
                    .into_string()
                    .map_err(|_| io::Error::from(io::ErrorKind::NotFound))?;
                Ok(new_path)
            }
        }

        fn fs_read_to_string(&mut self, path: &str) -> Result<String, io::Error> {
            std::fs::read_to_string(path)
        }
    }
}
#[cfg(any(target_family = "windows", target_family = "unix"))]
pub use os_api::*;

/// `CompilerEnv` is the primary interface for code using a compiler.
///
/// A `CompilerEnv` allows chaining compilers to manage things like variable
/// scope and compiling code generated by macros.
///
/// This both simplifies the macro API, and helps hide compiler internals.
///
#[derive(Debug, Clone)]
pub struct CompilerEnv {
    pub(crate) c: Strong<CompilerScope>,
}
impl CompilerEnv {
    pub fn new<A: SystemApi + 'static>(system_api: A) -> Self {
        let shared = SharedCompilerState {
            labels: HashMap::new(),
            system_api: Box::new(system_api),
        };
        Self {
            c: Strong::new(CompilerScope::new(Strong::new(shared))),
        }
    }

    pub fn with_parent(parent: CompilerEnv) -> Self {
        Self {
            c: Strong::new(CompilerScope::with_parent(parent)),
        }
    }

    /// Register built-in macros to this compiler.
    ///
    /// Current built-ins: m!/math!, eval!
    pub fn register_builtin_macros(&mut self) -> Result<(), CompileError> {
        let source = Source::new_unique("<builtin>", 0, 0);
        self.add_macro(
            EnvMode::Pass,
            &["m", "math"],
            builtin_macros::MathMacro::new(),
        )
        .map_err(|e| e.with_source(&source))?;
        self.add_macro(EnvMode::Pass, &["eval"], builtin_macros::EvalMacro::new())
            .map_err(|e| e.with_source(&source))?;
        Ok(())
    }

    /// Register a macro with one or more names leading to the same handler.
    ///
    /// If one of the names is already in-use, `CompilerError::DuplicateMacroName`
    /// may be returned.
    pub fn add_macro<S, N, M>(
        &mut self,
        mode: EnvMode,
        names: N,
        handler: M,
    ) -> Result<(), PassError>
    where
        S: AsRef<str>,
        N: IntoIterator<Item = S>,
        M: MacroHandler + 'static,
    {
        let macro_wrap = MacroWrap::new(Box::new(handler));
        let names_owned: Vec<String> = names.into_iter().map(|s| s.as_ref().to_owned()).collect();
        self.c.get_refmut().add_macro(mode, names_owned, macro_wrap)
    }

    pub fn add_define<N: AsRef<str>>(&mut self, mode: EnvMode, name: N, value: InstValue) {
        self.c
            .get_refmut()
            .add_define(mode, KString::from_ref(name.as_ref()), value)
    }

    pub fn get_define<'a>(&'a self, mode: EnvMode, name: &'a str) -> Option<ARef<'a, InstValue>> {
        CompilerScope::get_define(self.c.get_ref(), mode, name).ok()
    }

    /// Parse a string into an `InstValue`
    ///
    /// This is a convenience function for users to help extract defines from strings.
    pub fn parse_value(&self, input: &str) -> Result<InstValue, PassError> {
        use nom::{Finish, Parser};

        use crate::parser::common::*;
        let string_cache = &self.c.get_ref().string_cache;
        let mut parser = move |input| -> MyResult<InstValue> {
            let parse_arg = |inp| parse_instruction_arg_string(string_cache, inp);
            let (input, value) = parse_arg(input)?;
            let (input, _) = assert_input_consumed(parse_arg).parse(input)?;
            Ok((input, value))
        };
        // TODO better error mapping
        parser
            .parse(Span::new(input))
            .finish()
            .map(|v| v.1)
            .map_err(|e| PassError::from_eval_error(input, ParseError::from(e).into()))
    }

    pub fn parse(
        &mut self,
        input: &str,
        source_name: &str,
        parent: Option<Rc<Source>>,
    ) -> TResult<Vec<Statement>> {
        let mut source = Source::new(Rc::new(source_name.into()), 0, 0);
        source.parent = parent;

        let tokens = TokenParser::new(&self.c.get_ref().string_cache)
            .parse_str_input(input)
            .map_err(|e| {
                let e = ParseError::from(e);
                PassError::Syntax(e).with_source(&source)
            })?;
        crate::parser::tokens_to_statements(tokens, &source)
    }

    /// Handle compiler directives (e.g. include, .if/.else)
    pub fn expansion_pass(&mut self, tokens: Vec<Statement>) -> TResult<Vec<Statement>> {
        ExpansionPass::new(self).execute(tokens)
    }

    /// Resolve labels and relative jumps and verify correct outputs for each instruction
    pub fn finalize_code(&mut self, statements: Vec<Statement>) -> TResult<Vec<Statement>> {
        ConstAndLabelPass::new(self).execute(statements)
    }

    /// Generate code
    pub fn generate_code(&self, statements: &[Statement], f: &mut dyn fmt::Write) -> fmt::Result {
        write!(f, "{}", GenerateCode { statements })
    }

    /// Call a macro without an anonymous source and highest priority.
    ///
    /// This is mainly intended for testing purposes, and shouldn't be used in the main compiler
    /// code as it will lose track of the source.
    pub fn call_macro_simple(&mut self, name: &str, content: &str) -> TResult<Vec<Statement>> {
        self.call_macro(
            name,
            content,
            Source::new(Rc::new("anonymous".into()), 0, 0),
        )
    }

    pub fn call_macro(
        &mut self,
        name: &str,
        content: &str,
        location: Source,
    ) -> TResult<Vec<Statement>> {
        // Get the macro handler for this macro call, error if unknown. Note that we use Rc
        // to "clone" the internal reference so we no longer have a reference to Self
        let macro_fn =
            self.c.get_ref().get_macro(name).ok_or_else(|| {
                PassError::UnknownMacro { name: name.into() }.with_source(&location)
            })?;
        // We are now free to refer to self here
        let parent_source = Rc::new(location.clone());
        // Have the macro generate new tokens
        let mut extra_tokens = macro_fn
            .generate(self.clone(), location, name, content)
            .map_err(|e| {
                // If we can "unwrap" a CompileError, prefer to do so
                match e.downcast::<CompileError>() {
                    Ok(e2) => *e2,
                    Err(e2) => CompileError::MacroError((*parent_source).clone().into(), e2),
                }
            })?;
        // Set the parent sources for each of those tokens
        for mut tok2 in &mut extra_tokens {
            tok2.source.parent = Some(parent_source.clone());
        }
        Ok(extra_tokens)
    }

    fn test_condition(&mut self, source: &Source, cond: &str) -> TResult<bool> {
        let expr = ExpressionParser::<BasicOp, _, _>::new(match_name_basic, match_name_basic)
            .parse_expression(cond)
            .map_err(|error| {
                PassError::from_eval_error(cond, ParseError::from(error).into()).with_source(source)
            })?;
        let r = expr
            .eval(&mut self.get_eval_context(source, false))
            .unwrap_or_else(|_| AValue::from(false))
            .is_truthy();
        Ok(r)
    }

    /// Declare a new label or lookup an existing local label name, returning
    /// the found/created GLOBAL label name
    pub fn declare_label(&mut self, mode: EnvMode, name: &str) -> Result<KString, PassError> {
        self.c.get_refmut().declare_label(mode, name)
    }

    /// Lookup the GLOBAL label name for a given local label
    pub fn resolve_label(&self, mode: EnvMode, name: &str) -> Option<KString> {
        self.c.get_ref().get_global_label(mode, name)
    }

    /// Returns the destination for the GLOBAL label name
    pub fn get_label_dest(&self, name: &str) -> Option<usize> {
        self.c.get_ref().shared.get_ref().labels.get(name).copied()
    }

    /// Compile the code from start to finnish
    ///
    /// Yes, this doc comment is pundeful.
    pub fn compile(&mut self, source_name: &str, code: &str) -> TResult<Vec<Statement>> {
        let tokens = self.parse(code, source_name, None)?;
        let tokens = self.expansion_pass(tokens)?;
        let tokens = self.finalize_code(tokens)?;
        Ok(tokens)
    }

    pub fn compile_and_generate(&mut self, source_name: &str, code: &str) -> TResult<String> {
        let statements = self.compile(source_name, code)?;
        Ok(format!("{}", GenerateCode::new(&statements)))
    }

    /// Take code that has been parsed and expanded and change numeric jumps into labelled
    /// jumps, while also inserting the appropriate labels into the code.
    pub fn generate_labels(&mut self, source_name: &str, code: &str) -> TResult<Vec<Statement>> {
        let tokens = self.parse(code, source_name, None)?;
        let tokens = self.expansion_pass(tokens)?;
        let tokens = GenerateLabelsPass::new(self).execute(tokens)?;
        Ok(tokens)
    }

    /// Returns an evaluation context suitable for use with `Expression::evaluate()`
    ///
    /// If `partial` is true then constants MUST be fully evaluated, otherwise
    /// evaluating a const-expression may return another const-expression. This
    /// is unrelated to full/partial evaluation of expressions themselves.
    ///
    pub fn get_eval_context<'a>(
        &'a mut self,
        source: &'a Source,
        partial: bool,
    ) -> ConstExprEval<'a> {
        ConstExprEval::new(self, source, partial)
    }

    /// Resolve a const-expression `InstValue` to a final `AValue` or partially
    /// evaluate the expression if full evaulation isn't yet possible.
    pub fn simplify_inst_value(
        &mut self,
        val: InstValue,
        source: &Source,
        partial: bool,
    ) -> TResult<InstValue> {
        ConstExprEval::new(self, source, partial).simplify(val)
    }

    /// Set the @counter value used when expanding labels and jumps
    pub fn set_counter(&mut self, counter: Option<usize>) {
        self.c.get_refmut().counter = counter;
    }

    pub fn get_counter(&self) -> Option<usize> {
        self.c.get_ref().counter
    }

    pub fn get_default_mode(&self) -> EnvMode {
        self.c.get_ref().default_mode
    }
    pub fn set_default_mode(&mut self, mode: EnvMode) {
        self.c.get_refmut().default_mode = mode;
    }

    /// Set a compiler option by key/value pair
    pub fn set_option(&mut self, key: &str, value: &str) -> Result<(), PassError> {
        let mut cref = self.c.get_refmut();
        match key {
            OPTION_LABEL_MODE => {
                cref.options.label_mode = CompilerOptions::parse_opt_mode(key, value)?;
            }
            _ => {
                return Err(PassError::UnknownOption { key: key.into() });
            }
        }
        Ok(())
    }

    pub fn string_cache(&self) -> ARef<StringCache> {
        ARef::new(self.c.get_ref()).map(|c| &c.string_cache)
    }

    pub fn system_api(&self) -> impl BorrowMut<Box<dyn SystemApi>> {
        type BoxApi = Box<dyn SystemApi>;
        struct Owner {
            a: RefMut<SharedCompilerState>,
        }
        impl Borrow<BoxApi> for Owner {
            fn borrow(&self) -> &BoxApi {
                &self.a.system_api
            }
        }
        impl BorrowMut<BoxApi> for Owner {
            fn borrow_mut(&mut self) -> &mut BoxApi {
                &mut self.a.system_api
            }
        }
        Owner {
            a: self.c.get_ref().shared.get_refmut(),
        }
    }
}
impl PartialEq for CompilerEnv {
    fn eq(&self, other: &Self) -> bool {
        self.c.get_ref() == other.c.get_ref()
    }
}

pub type ConstOp = bn_expression::basic::BasicOp;

/// Eval context for const-expressions
///
/// All names are automatically assumed to be constants and are looked-up
/// accordingly. A const-expr can evaluate to a simplified const-expr if desired.
/// This eval context will error out on any attempt to recursively resolve names.
pub struct ConstExprEval<'a> {
    env: &'a mut CompilerEnv,
    source: &'a Source,
    partial: bool,
    recursive_guard: Vec<String>,
}
impl<'a> ConstExprEval<'a> {
    pub fn new(env: &'a mut CompilerEnv, source: &'a Source, partial: bool) -> Self {
        Self {
            env,
            source,
            partial,
            recursive_guard: Vec::new(),
        }
    }

    pub fn eval(&mut self, expr: &Expression<ConstOp>) -> Result<AValue, EvalError> {
        expr.eval(self)
    }

    pub fn partial_eval(
        &mut self,
        expr: &Expression<ConstOp>,
    ) -> Result<Expression<ConstOp>, EvalError> {
        expr.partial_eval(self)
    }

    /// Simplify an `InstValue` expression or constant into a concrete value
    pub fn simplify(&mut self, val: InstValue) -> TResult<InstValue> {
        match val {
            InstValue::Const(a) => {
                let r = self.env.get_define(EnvMode::Global, &a).map(|v| v.clone());
                r.ok_or_else(|| {
                    PassError::from(EvalError::UnknownVariable {
                        name: a.as_str().into(),
                    })
                    .with_source(self.source)
                })
            }
            InstValue::ConstExpr(expr) => {
                // Dealing with a regular constexpr
                match expr.evaluate(self.partial, self) {
                    Ok(expr2) => {
                        if let Some(value2) = expr2.as_value() {
                            Ok(value2.clone().into())
                        } else if self.partial {
                            // We're allowed to have partials and we got a partial so resolve to partial
                            Ok(InstValue::new_expr(expr2))
                        } else {
                            // TODO better reporting on what went wrong
                            Err(PassError::from(EvalError::UnresolvedValue)
                                .with_source(self.source))
                        }
                    }
                    Err(error) => {
                        let error2 = match error.downcast::<PassError>() {
                            Ok(e) => *e,
                            Err(e) => PassError::from(e),
                        };
                        Err(error2.with_source(self.source))
                    }
                }
            }
            InstValue::QuickConstExpr(key, value) => {
                match key.as_str() {
                    // label jump
                    FUNC_LABEL_DEST => {
                        let expr =
                            Expression::new_call(key.as_str(), vec![AValue::string(value).into()]);
                        self.simplify(InstValue::new_expr(expr))
                    }
                    _ => Err(PassError::UnknownQuickConstKey(key.into(), value.into())
                        .with_source(self.source)),
                }
            }
            _ => Ok(val),
        }
    }

    fn call_fn_defined(
        &mut self,
        name: &str,
        args: &[AValue],
    ) -> Result<Expression<ConstOp>, EvalError> {
        // Get const name
        let c_name = args
            .get(0)
            .and_then(|v| v.as_string())
            .ok_or_else(|| EvalError::invalid_arg(name, 0))?;
        let is_def = self.env.get_define(EnvMode::Pass, c_name).is_some();
        Ok(AValue::from(is_def).into())
    }

    fn call_fn_label(
        &mut self,
        name: &str,
        args: &[AValue],
    ) -> Result<Expression<ConstOp>, EvalError> {
        // Get label name
        let label_name = args
            .get(0)
            .and_then(|v| v.as_string())
            .ok_or_else(|| EvalError::invalid_arg(name, 0))?;
        // Resolve to global label
        let name2 = if let Some(global_name) = self.env.resolve_label(EnvMode::Pass, label_name) {
            global_name
        } else {
            self.env
                .declare_label(EnvMode::Pass, label_name)
                .map_err(|e| EvalError::other(e.with_source(self.source)))?
        };
        // If we can resolve to dest, do so
        if self.env.get_counter().is_some() {
            // Grab the label dest, if it's max then consider it undefined.
            let dest = self.env.get_label_dest(&name2).and_then(|v| {
                if v == usize::MAX {
                    None
                } else {
                    Some(v)
                }
            });
            // Error mapping
            let dest = dest.ok_or_else(|| {
                EvalError::other(PassError::UnknownLabel {
                    name: Label::strip_suffix(name2.as_str()).to_string(),
                })
            })?;
            Ok(AValue::from(dest as f64).into())
        } else {
            Ok(Expression::Call(
                FUNC_LABEL_DEST.into(),
                vec![AValue::string(name2.as_str()).into()],
            ))
        }
    }

    fn is_recursive(&self, name: &str) -> bool {
        self.recursive_guard.iter().any(|e| e.as_str() == name)
    }
}
impl<'a> EvalContext<ConstOp> for ConstExprEval<'a> {
    fn get_variable(&mut self, name: &str) -> Result<AValue, EvalError> {
        if name == VAR_COUNTER {
            let r = self
                .env
                .get_counter()
                .map(|v| AValue::Num(v as f64))
                .unwrap_or_else(|| AValue::name(name));
            Ok(r)
        } else if self.is_recursive(name) {
            // Error out on recursive expansion
            Err(EvalError::Other(Box::new(
                PassError::RecrusiveConstantExpansion { name: name.into() }
                    .with_source(self.source),
            )))
        } else {
            let v1 = self
                .env
                .get_define(EnvMode::Global, name)
                .ok_or_else(|| EvalError::UnknownVariable { name: name.into() })?
                .clone();
            let v2 = if !v1.is_concrete() {
                // Guard oursevles against recursive expansion
                self.recursive_guard.push(name.into());
                let v2 = self
                    .simplify(v1)
                    .map_err(|e| EvalError::Other(Box::new(e)))?;
                // Remove guard
                self.recursive_guard.pop();
                v2
            } else {
                v1
            };
            v2.into_value().ok_or(EvalError::UnresolvedValue)
        }
    }

    fn call(&mut self, name: &str, args: Vec<AValue>) -> Result<Expression<ConstOp>, EvalError> {
        match name {
            FUNC_DEFINED => self.call_fn_defined(name, &args),
            FUNC_LABEL_DEST => self.call_fn_label(name, &args),
            _ => Err(EvalError::UnknownFunction { name: name.into() }),
        }
    }

    fn get_function_type(&self, name: &str) -> FunctionType {
        match name {
            FUNC_DEFINED => FunctionType::Eval,
            FUNC_LABEL_DEST => FunctionType::Eval,
            _ => FunctionType::Unknown,
        }
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub struct CompilerOptions {
    /// Mode to use when setting defines
    pub define_mode: EnvMode,
    /// Should we generate local names for labels, leave them as global,
    /// or pass to the parent `CompilerOptions`?
    pub label_mode: EnvMode,
}
impl CompilerOptions {
    pub fn parse_opt_mode(key: &str, value: &str) -> Result<EnvMode, PassError> {
        let err_message = "Must be one of 'pass', 'local', or 'global'";
        EnvMode::from_str_ignore_case(value)
            .ok_or_else(|| PassError::option_value_error(key, value, err_message))
    }
}
impl Default for CompilerOptions {
    fn default() -> Self {
        Self {
            define_mode: EnvMode::Pass,
            label_mode: EnvMode::Pass,
        }
    }
}

#[derive(Debug)]
pub struct SharedCompilerState {
    /// Map of labels to final output
    labels: HashMap<KString, usize>,
    /// System API
    system_api: Box<dyn SystemApi>,
}

/// A compiler stores the state necessary to
#[derive(Debug, Clone)]
pub struct CompilerScope {
    /// All defined constants
    defines: HashMap<KString, InstValue>,
    /// Map of macro names to handlers
    macros: HashMap<KString, Rc<MacroWrap>>,
    /// Map of local to global label names
    label_names: HashMap<KString, KString>,
    /// Current compiler line / @counter position, or None if we're not in the correct pass
    counter: Option<usize>,
    /// Default env mode for this compiler state
    default_mode: EnvMode,
    /// Options
    options: CompilerOptions,
    /// String cache, shared between ALL compiler instances
    string_cache: StringCache,
    /// Reference to shared state
    shared: Strong<SharedCompilerState>,
    /// Parent compiler. If this is set, certain things are forwarded
    /// to the parent instead of being resolved in this compiler.
    parent: Option<Strong<CompilerScope>>,
}
impl CompilerScope {
    pub fn new(shared: Strong<SharedCompilerState>) -> Self {
        Self::new_with_values(shared, None)
    }

    pub fn with_parent(env: CompilerEnv) -> Self {
        let shared = env.c.get_ref().shared.clone();
        Self::new_with_values(shared, Some(env.c))
    }

    fn new_with_values(shared: Strong<SharedCompilerState>, parent: Option<Strong<Self>>) -> Self {
        let string_cache = parent
            .clone()
            .map(|p| p.get_ref().string_cache.clone())
            .unwrap_or_default();
        Self {
            defines: HashMap::new(),
            macros: HashMap::new(),
            label_names: HashMap::new(),
            counter: None,
            string_cache,
            default_mode: EnvMode::Pass,
            options: CompilerOptions::default(),
            shared,
            parent,
        }
    }

    ///
    pub fn add_define(&mut self, mode: EnvMode, name: KString, value: InstValue) {
        if self.local_mode(self.first_mode(&[mode, self.options.define_mode, self.default_mode])) {
            self.defines.insert(name, value);
        } else {
            self.parent_refmut().add_define(mode, name, value);
        }
    }

    /// Returns the concrete value of a "define" or None if undefined
    pub fn get_define(me1: Ref<Self>, mode: EnvMode, name: &str) -> Result<ARef<InstValue>, ()> {
        ARef::new(me1.clone())
            .try_map(|me| me.defines.get(name).ok_or(()))
            .or_else(|_| {
                if me1.local_mode(me1.first_mode(&[mode, me1.default_mode])) {
                    Err(())
                } else {
                    Self::get_define(me1.parent_ref(), mode, name)
                }
            })
    }

    /// See [`CompilerEnv::declare_label`].
    pub fn declare_label(&mut self, mode: EnvMode, name: &str) -> Result<KString, PassError> {
        let mode2 = EnvMode::take_first(&[mode, self.options.label_mode, self.default_mode]);
        if self.shared.get_ref().labels.contains_key(name) {
            // Handle existing global label
            Ok(KString::from_ref(name))
        } else if self.local_or_pass_mode(mode2) && self.label_names.contains_key(name) {
            // Handle existing local label
            Ok(self.label_names.get(name).unwrap().clone())
        } else if self.local_mode(mode2) {
            // Create new label
            let label_count = self.shared.get_ref().labels.len();
            let new_name = if self.options.label_mode == EnvMode::Local {
                format!(
                    "{}.{}{}{}",
                    name, label_count, LABEL_SUFFIX_START, label_count
                )
            } else {
                format!("{}{}{}", name, LABEL_SUFFIX_START, label_count)
            };
            let new_name = KString::from(new_name);
            self.label_names
                .insert(KString::from_ref(name), new_name.clone());
            self.shared
                .get_refmut()
                .labels
                .insert(new_name.clone(), usize::MAX);
            Ok(new_name)
        } else {
            // Recurse to parent
            self.parent_refmut().declare_label(mode, name)
        }
    }

    /// Returns the global label name of the given local label `name`.
    pub fn get_global_label(&self, mode: EnvMode, name: &str) -> Option<KString> {
        if let Some(name2) = self.label_names.get(name) {
            Some(name2.clone())
        } else if let Some(p) = self.parent.as_ref() {
            p.get_ref().get_global_label(mode, name)
        } else if self.shared.get_ref().labels.contains_key(name) {
            Some(KString::from_ref(name))
        } else {
            None
        }
    }

    /// Sets the GLOBAL label position for the label with the given *global* name.
    pub fn assign_label_position(&mut self, name: &str, line: usize) -> Result<(), PassError> {
        let mut shared = self.shared.get_refmut();
        let current = shared.labels.get(name).unwrap();
        if *current != usize::MAX {
            // Strip the @ suffix from the label name
            let label_name = Label::strip_suffix(name).to_string();
            Err(PassError::DuplicateLabelName(label_name))
        } else {
            shared.labels.insert(KString::from_ref(name), line);
            Ok(())
        }
    }

    /// Add a wrapped macro
    fn add_macro(
        &mut self,
        mode: EnvMode,
        names: Vec<String>,
        handler: Rc<MacroWrap>,
    ) -> Result<(), PassError> {
        if self.local_mode(self.first_mode(&[mode])) {
            for key in names {
                if self.macros.contains_key(key.as_str()) {
                    return Err(PassError::DuplicateMacroName { name: key });
                }
                self.macros.insert(key.into(), handler.clone());
            }
            Ok(())
        } else {
            self.parent_refmut().add_macro(mode, names, handler)
        }
    }

    /// Get the macro wrapper for the named macro
    fn get_macro(&self, name: &str) -> Option<Rc<MacroWrap>> {
        self.macros.get(name).map(Clone::clone).or_else(|| {
            self.parent
                .as_ref()
                .and_then(|p| p.get_ref().get_macro(name))
        })
    }

    /// Return true if the local state should be updated, false to pass the update on to parent
    pub fn local_mode(&self, mode: EnvMode) -> bool {
        if self.parent.is_none() {
            true
        } else {
            matches!(mode, EnvMode::Local)
        }
    }

    pub fn local_or_pass_mode(&self, mode: EnvMode) -> bool {
        if self.parent.is_none() {
            true
        } else {
            matches!(mode, EnvMode::Local | EnvMode::Pass)
        }
    }

    /// Convenience function
    fn first_mode(&self, modes: &[EnvMode]) -> EnvMode {
        EnvMode::take_first(modes)
    }

    fn parent_ref(&self) -> Ref<Self> {
        self.parent.clone().unwrap().get_ref()
    }

    fn parent_refmut(&mut self) -> RefMut<Self> {
        self.parent.clone().unwrap().get_refmut()
    }
}
impl PartialEq for CompilerScope {
    fn eq(&self, other: &Self) -> bool {
        if !(self.defines == other.defines
            && self.macros == other.macros
            && self.options == other.options
            && self.string_cache == other.string_cache
            && self.default_mode == other.default_mode)
        {
            return false;
        }
        match (&self.parent, &other.parent) {
            (Some(lh), Some(rh)) => lh.get_ref() == rh.get_ref(),
            _ => false,
        }
    }
}

struct ExpansionPass<'a> {
    env: &'a mut CompilerEnv,
    new_tokens: Vec<Statement>,
}
impl<'a> ExpansionPass<'a> {
    pub fn new(env: &'a mut CompilerEnv) -> Self {
        Self {
            env,
            new_tokens: Vec::new(),
        }
    }

    pub fn execute(mut self, mut tokens: Vec<Statement>) -> Result<Vec<Statement>, CompileError> {
        let mut errors = Vec::new();
        for tok in tokens.drain(..) {
            match tok.data {
                StatementData::Directive(dir) => self.handle_directive(&tok.source, dir),
                StatementData::Instruction(instr) => self.handle_instruction(tok.source, instr),
                StatementData::Label(lbl) => self.handle_label(tok.source, lbl),
                StatementData::MacroCall(call) => {
                    self.handle_macro(tok.source, &call.name, &call.content)
                }
                StatementData::Comment(comment) => self.handle_comment(tok.source, comment),
            }
            .unwrap_or_else(|e| {
                e.append_to(&mut errors);
            })
        }
        ok_or_many_errors(self.new_tokens, errors)
    }

    fn handle_instruction(&mut self, source: Source, mut instr: Instruction) -> TResult<()> {
        instr.resolve_values(|val| self.env.simplify_inst_value(val, &source, true))?;

        // Special handling to patch jump labels
        if let Instruction::Jump(i_jump) = &mut instr {
            (i_jump.dest.as_name())
                .map(|name| self.env.declare_label(EnvMode::Pass, name))
                .transpose()
                .map_err(|e| e.with_source(&source))?
                .map(|name| {
                    i_jump.dest = InstValue::new_name(name);
                });
        }

        self.new_tokens.push(Statement {
            source,
            data: StatementData::Instruction(instr),
        });
        Ok(())
    }

    fn handle_directive(&mut self, source: &Source, dir: Directive) -> TResult<()> {
        match dir {
            Directive::Define(define) => {
                self.env.add_define(EnvMode::Pass, define.key, define.value);
                Ok(())
            }
            Directive::If(d_if) => self.expand_if(source, &d_if),
            Directive::Include { path } => self.handle_include(source, &path),
            Directive::DefineMacro(macro_def) => {
                let name = macro_def.name.clone();
                let handler = UserMacro::new(source.clone(), macro_def);
                self.env
                    .add_macro(EnvMode::Pass, &[name], handler)
                    .map_err(|e| e.with_source(source))
            }
            Directive::Option(opt) => self.handle_option(source, opt),
            Directive::InlineExtension {
                ext_type: _,
                code: _,
            } => Err(PassError::UnsupportedFeature {
                feature: "inline extensions".into(),
            }
            .with_source(source)),
            Directive::LoadExtension { ext_type, path: _ } => {
                let err =
                    PassError::UnsupportedExtensionType { name: ext_type }.with_source(source);
                Err(err)
            }
        }
    }

    fn expand_if(&mut self, source: &Source, d_if: &DirectiveIf) -> TResult<()> {
        if d_if.cond.is_empty() || self.env.test_condition(source, &d_if.cond)? {
            // Expand and append new statements
            let mut extra_tokens = self.env.expansion_pass(d_if.statements.clone())?;
            self.new_tokens.append(&mut extra_tokens);
        } else if let Some(else_if) = &d_if.else_if {
            self.expand_if(source, else_if)?
        }
        Ok(())
    }

    fn handle_include(&mut self, source: &Source, path: &str) -> TResult<()> {
        let parent_src = Rc::new(source.clone());
        let mut system_api = self.env.system_api();
        let absolute_path = system_api
            .borrow()
            .resolve_path(&source.name, path)
            .map_err(|e| PassError::IO(e).with_source(source))?;
        let input = system_api
            .borrow_mut()
            .fs_read_to_string(&absolute_path)
            .map_err(|e| PassError::IO(e).with_source(source))?;

        let mut ctx2 = CompilerEnv::with_parent(self.env.clone());
        let tokens = ctx2.parse(&input, path, Some(parent_src))?;
        let mut tokens = ctx2.expansion_pass(tokens)?;
        self.new_tokens.append(&mut tokens);
        Ok(())
    }

    fn handle_option(&mut self, source: &Source, opt: DirectiveOption) -> TResult<()> {
        self.env
            .set_option(&opt.key, &opt.value)
            .map_err(|e| e.with_source(source))
    }

    fn handle_label(&mut self, source: Source, label: Label) -> TResult<()> {
        let new_name = self
            .env
            .declare_label(EnvMode::Pass, &label.name)
            .map_err(|e| e.with_source(&source))?;
        self.new_tokens
            .push(Statement::new(source, StatementData::new_label(new_name)));
        Ok(())
    }

    fn handle_macro(&mut self, source: Source, name: &str, content: &str) -> TResult<()> {
        // Add new tokens to our current token map
        let extra_tokens = self.env.call_macro(name, content, source)?;
        // TODO add new env context for this expansion pass
        let mut extra_tokens = self.env.expansion_pass(extra_tokens)?;
        self.new_tokens.append(&mut extra_tokens);
        Ok(())
    }

    fn handle_comment(&mut self, source: Source, comment: String) -> TResult<()> {
        self.new_tokens
            .push(Statement::new(source, StatementData::Comment(comment)));
        Ok(())
    }
}

/// Assigns label locations.
/// This is a struct in case this becomes more complex later.
struct AssignLabelsPass<'a> {
    env: &'a mut CompilerEnv,
}
impl<'a> AssignLabelsPass<'a> {
    pub fn new(env: &'a mut CompilerEnv) -> Self {
        Self { env }
    }

    pub fn execute(&mut self, tokens: &[Statement]) -> TResult<()> {
        let mut errors = Vec::new();
        let mut instr_count = 0;
        let mut c_ref = self.env.c.get_refmut();
        for tok in tokens.iter() {
            match &tok.data {
                StatementData::Instruction { .. } => {
                    instr_count += 1;
                }
                StatementData::Label(label) => {
                    c_ref
                        .assign_label_position(&label.name, instr_count)
                        .unwrap_or_else(|e| e.with_source(&tok.source).append_to(&mut errors));
                }
                StatementData::Comment(_) => {}
                _ => {
                    PassError::LabelAssignmentInvalidStatement(format!("{:?}", &tok))
                        .with_source(&tok.source)
                        .append_to(&mut errors);
                }
            }
        }
        ok_or_many_errors((), errors)
    }
}

/// Compiler pass that replaces constants and fills in labels.
///
/// By this stage, ALL instructions are generated, so label locations can be finalized.
/// There should be no more macros, but constants are allowed, and we can have certain
/// compiler directives (such as .position).
struct ConstAndLabelPass<'a> {
    env: &'a mut CompilerEnv,
    new_tokens: Vec<Statement>,
}
impl<'a> ConstAndLabelPass<'a> {
    pub fn new(env: &'a mut CompilerEnv) -> Self {
        Self {
            env,
            new_tokens: Vec::new(),
        }
    }

    pub fn execute(mut self, tokens: Vec<Statement>) -> Result<Vec<Statement>, CompileError> {
        let mut errors = Vec::new();
        // Step 1: decide on line numbers for each label
        AssignLabelsPass::new(self.env)
            .execute(&tokens)
            .unwrap_or_else(|e| e.append_to(&mut errors));
        // Step 2: generate new tokens, removing remaining label tokens and resolving labels
        self.generate_tokens(tokens)
            .unwrap_or_else(|e| e.append_to(&mut errors));
        // Step 3: consume self and return new tokens
        ok_or_many_errors(self.new_tokens, errors)
    }

    fn generate_tokens(&mut self, mut tokens: Vec<Statement>) -> Result<(), CompileError> {
        let mut errors = Vec::new();
        let mut instr_count = 0;
        for tok in tokens.drain(..) {
            self.env.set_counter(Some(instr_count));
            match tok.data {
                StatementData::Instruction(instr) => {
                    match self.handle_instruction(tok.source, instr) {
                        Ok(_) => {}
                        Err(e) => {
                            errors.push(e);
                        }
                    }
                    instr_count += 1;
                }
                StatementData::Comment(_) => self.new_tokens.push(tok),
                StatementData::Label(mut label) => {
                    label.name = Label::strip_suffix(&label.name).to_string();
                    self.new_tokens.push(Statement::new(tok.source, label));
                }
                _ => {}
            }
        }
        ok_or_many_errors((), errors)
    }

    fn handle_instruction(&mut self, source: Source, mut instr: Instruction) -> TResult<()> {
        // Resolve any pending values
        instr.resolve_values(|val| self.env.simplify_inst_value(val, &source, false))?;
        // Make sure the output is valid
        instr.check_output().map_err(|e| e.with_source(&source))?;
        // If it's a jump instruction, assert that the destination is a number or named label
        // and if it's a label, strip the suffix.
        if let Instruction::Jump(jump_i) = &mut instr {
            (jump_i.dest.as_name())
                .map(|name| {
                    self.env
                        .get_label_dest(name)
                        .ok_or_else(|| PassError::unknown_label(name).with_source(&source))
                        .map(|_| InstValue::new_name(Label::strip_suffix(name)))
                })
                .transpose()?
                .map(|name| {
                    jump_i.dest = name;
                });
        }
        // Append modified instruction
        self.new_tokens
            .push(Statement::new(source, StatementData::Instruction(instr)));
        Ok(())
    }
}

struct GenerateLabelsPass<'a> {
    env: &'a mut CompilerEnv,
    new_tokens: Vec<Statement>,
    /// Map of lines/instruction indexes to (label_name, is_generated)
    known_labels: HashMap<usize, (KString, bool)>,
    dests: Vec<usize>,
    label_prefix: String,
}
impl<'a> GenerateLabelsPass<'a> {
    pub fn new(env: &'a mut CompilerEnv) -> Self {
        Self {
            env,
            new_tokens: Vec::new(),
            known_labels: HashMap::new(),
            dests: Vec::new(),
            // TODO a way to customize this?
            label_prefix: "auto_label_".into(),
        }
    }

    pub fn execute(mut self, statements: Vec<Statement>) -> TResult<Vec<Statement>> {
        // Step 1: find all numeric jump destinations, and any labels
        self.find_jump_dests(&statements)?;
        // Step 2: generate new labels for each un-labelled line
        self.generate_new_labels()?;
        // Step 3: insert label statements and modify jumps to use the labels
        self.inject_statements(statements)?;
        Ok(self.new_tokens)
    }

    fn find_jump_dests(&mut self, statements: &[Statement]) -> TResult<()> {
        let mut instr_count = 0usize;
        for stmt in statements {
            match &stmt.data {
                StatementData::Instruction(instr) => {
                    // Try to track the jump destination
                    if let Instruction::Jump(i_jump) = instr {
                        self.try_add_dest(&i_jump.dest);
                    }
                    instr_count += 1;
                }
                StatementData::Label(label) => {
                    // Add to list of known labels
                    self.known_labels
                        .insert(instr_count, (KString::from_ref(&label.name), false));
                }
                _ => {}
            }
        }
        Ok(())
    }

    fn try_add_dest(&mut self, dest: &InstValue) {
        if let InstValue::Value(AValue::Num(n)) = dest {
            let line = *n as usize;
            match self.dests.binary_search(&line) {
                Ok(_) => {} // line already in vector
                Err(index) => self.dests.insert(index, line),
            }
        }
    }

    fn generate_new_labels(&mut self) -> TResult<()> {
        for line in &self.dests {
            if !self.known_labels.contains_key(line) {
                // Generate a new unique name
                let mut name = format!("{}{}", self.label_prefix, line);
                while self.env.resolve_label(EnvMode::Pass, &name).is_some() {
                    name.push('_');
                }
                let label_name = self
                    .env
                    .declare_label(EnvMode::Global, &name)
                    .map_err(|e| e.with_source(&Source::new_unique("<builtin>", 0, 0)))?;
                self.known_labels.insert(*line, (label_name, true));
            }
        }
        Ok(())
    }

    fn inject_statements(&mut self, mut statements: Vec<Statement>) -> TResult<()> {
        // source for generated labels
        let source = Source::new_unique(SOURCE_AUTO_LABEL, 0, 0);
        let mut instr_count = 0;
        for mut stmt in statements.drain(..) {
            // Inject generated labels
            if let Some((label, is_generated)) = self.known_labels.get(&instr_count) {
                if *is_generated {
                    let source = source.clone().with_position(instr_count as u32, 0);
                    let label = Label::new(Label::strip_suffix(label.as_str()));
                    self.new_tokens.push(Statement::new(source, label));
                }
            }
            // Modify existing instructions
            match &mut stmt.data {
                StatementData::Instruction(instr) => {
                    if let Instruction::Jump(i_jump) = instr {
                        self.try_modify_dest(i_jump)?;
                    }
                    instr_count += 1;
                }
                StatementData::Label(label) => {
                    label.name = Label::strip_suffix(&label.name).to_string();
                }
                _ => {}
            }
            self.new_tokens.push(stmt);
        }
        Ok(())
    }

    fn try_modify_dest(&self, jump_i: &mut InstructionJump) -> TResult<()> {
        // Attempt to replace numeric jump targets with labels
        if let InstValue::Value(AValue::Num(n)) = jump_i.dest {
            let line = n as usize;
            if let Some((label, _)) = self.known_labels.get(&line) {
                let label = Label::strip_suffix(label);
                let cache = self.env.string_cache();
                jump_i.dest = InstValue::new_quick(FUNC_LABEL_DEST, label, &cache);
            }
        }
        // Attempt to convert resolved quick-const labels back into quick-const
        #[allow(clippy::collapsible_match)]
        if let InstValue::ConstExpr(expr) = &jump_i.dest {
            if let Expression::Call(name, args) = expr {
                if name.as_ref() == FUNC_LABEL_DEST && args.len() == 1 {
                    let label_name = args[0]
                        .as_value()
                        .and_then(|v| v.as_string())
                        .map(Label::strip_suffix);
                    if let Some(label_name) = label_name {
                        let cache = self.env.string_cache();
                        jump_i.dest = InstValue::new_quick(FUNC_LABEL_DEST, label_name, &cache);
                    } else {
                        // TODO bug or user error?
                    }
                }
            }
        }
        Ok(())
    }
}

/// Returns `ok` if `errors.is_empty()` else `errors`
fn ok_or_many_errors<O>(ok: O, errors: Vec<CompileError>) -> Result<O, CompileError> {
    if errors.is_empty() {
        Ok(ok)
    } else {
        Err(CompileError::many(errors))
    }
}

/// Takes a slice of statements and implements `Display` to make it easy to write
/// the code to different outputs.
#[derive(Debug)]
pub struct GenerateCode<'a> {
    statements: &'a [Statement],
}
impl<'a> GenerateCode<'a> {
    pub fn new(statements: &'a [Statement]) -> Self {
        Self { statements }
    }
}
impl<'a> fmt::Display for GenerateCode<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for stmt in self.statements {
            stmt.data.generate(f)?;
            writeln!(f)?
        }
        Ok(())
    }
}
